{"meta":{"title":"YiAiluo‘s BLOG","subtitle":"爱自己是终身浪漫的开始","description":"","author":"易霭珞","url":"https://yiailuo.github.io","root":"/"},"pages":[],"posts":[{"title":"Docker核心技术-易霭珞","slug":"Docker核心技术","date":"2022-11-30T13:27:50.490Z","updated":"2022-11-30T13:33:39.164Z","comments":true,"path":"Docker核心技术/","link":"","permalink":"https://yiailuo.github.io/Docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/","excerpt":"","text":"Docker核心技术初识Docker 基于Linux内核的Cgoup，NameSpace，以及Union FS等技术，对进程进行封装隔离，属于操作系统层面的虚拟技术，由于隔离的进程独立于宿主和其他的隔离的进程，因此也被称为容器。 Docker在容器的基础上，进行了进一步的封装，从文件系统，网络互联网到进程隔离等等，极大的简化了容器的创建和维护，使得Docker技术比虚拟机技术更为简便、快捷。 为什么要用Docker？它有哪些特性和优势？ 它能更高效的利用系统资源、更快速的启动时间、一致的运行环境、更轻松的迁移、更轻松的维护和扩展 ​ 特性：安全性、隔离性、便携性、可配额 Docker与虚拟机的区别 参考链接：Docker与虚拟机的区别 - 简书 (jianshu.com) 容器操作​ 启动： docker run ​ -it 交互 ​ -d 后台运行 ​ -p 端口映射 ​ -v 磁盘挂载 启动已终止的容器：docker start 停止容器：docker stop 查看容器进程：docker ps 查看容器细节：docker inspect [containerid] 进入容器：docker attach ​ docker exec 通过 nsenter： 123PID=$(docker inspect -- format &quot;&#123;&#123;.State.Pid&#125;&#125;&quot;)[container])$ nsenter --target $PID --mount --uts --ipc --net --pid 拷贝文件至容器内：docker cp file [container:id]:&#x2F;file-to-path 什么是 Dockerfile？Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。 Dockerfile详情使用参考教程Docker Dockerfile详解使用_Charge8的博客-CSDN博客_docker dockerfile 查看Dockerfile： 例： FROM ubuntu ENV MY_SERVICE_PORT&#x3D;80 ADD bin&#x2F;amd64&#x2F;httpserver&#x2F;httpserver ENTRYPOINT &#x2F;httpserver 将Dockerfile打包成镜像： 例： docker build -t cncamp&#x2F;httpserver:${tag} docker push cncamp&#x2F;httpserver:v1.0 运行容器： 例： docker run -d cncamp&#x2F;httpserver:v1.0 什么是NameSpace？NameSpace是Linux内核用来隔离内核资源的方式。 NameSpace的特点： 系统可以为进程分配不同的 Namespace； 并保证不同的 Namespace 资源独立分配、进程彼此隔离，即不同的 Namespace 下的进程互不干扰 。 通过 Namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源。这两拨进程相互独立且隔离无法感知到对方的存在。具体的实现方式是把一个或多个进程的相关资源指定在同一个 namespace 中。 进程的数据结构实现 123456struct task_struct &#123;.../* namespaces */struct nsproxy *nsproxy;...&#125; namespace的数据结构实现 123456struct nsproxy &#123;atomic_t count;struct uts_namespace *uts_ns; struct ipc_namespace *ipc_ns; struct mnt_namespace *mnt_ns; struct pid_namespace*pid_ns_for_children;struct net *net_ns;&#125; NameSpace的用途：从 docker 实现者的角度考虑如何实现一个资源隔离的容器。可以通过 chroot 命令切换根目录的挂载点，从而隔离文件系统。为了在分布式的环境下进行通信和定位，容器必须要有独立的 IP、端口和路由等，这就需要对网络进行隔离。同时容器还需要一个独立的主机名以便在网络中标识自己。接下来还需要进程间的通信、用户权限等的隔离。最后，运行在容器中的应用需要有进程号(PID)，自然也需要与宿主机中的 PID 进行隔离。也就是说这六种隔离能力是实现一个容器的基础， 名称 宏定义 隔离的资源 IPC CLONE_NEWIPC 信号量、共享内存和POSIX 消息队列 Network CLONE_NEWNET 网络设备，网络栈，端口等 Mount CLONE_NEWNS 文件挂载点 PID CLONE_NEWPID 进程编号 User CLONE_NEWUSER 用户和用户组 UTS CLONE_NEWUTS 主机名和NIS域名 NameSpace的常用操作： 查看当前系统的namespace： 1lsns -t &lt;type&gt; 查看某进程的namespace: 1ls -la /proc/&lt;pid&gt;/ns/ 进入某namespace运行命令: 1nsenter -t &lt;pid&gt; -n ip addr 在新network namespace 执行sleep指令： 1unshare -fn sleep 60 查看进程信息 1ps -ef|grep sleep 查看网络NameSpace 1lsns -t net 参考：极客时间训练营—–Docker教程Linux Namspace：简介","categories":[],"tags":[]},{"title":"SpringSecurity-自定义控制器Handler","slug":"SpringSecurity学习2-自定义控制器Handler","date":"2022-09-30T04:33:52.928Z","updated":"2022-11-30T13:13:44.194Z","comments":true,"path":"SpringSecurity学习2-自定义控制器Handler/","link":"","permalink":"https://yiailuo.github.io/SpringSecurity%E5%AD%A6%E4%B9%A02-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E5%88%B6%E5%99%A8Handler/","excerpt":"","text":"续接第一篇文章的入门demoSpringSecurity学习1-入门详解 为什么要自定义控制器Handler？在上一篇的demo中，我们在登录成功后，跳转页面用到了successForwardUrl() ，表示成功后转发请求到地址。内部是通过 successHandler() 方法进行控制成功后交给哪个类进行处理 源码分析可以看到sucessForwardUrl将forwordUrl 转发给ForwardAuthenticationSuccessHandler类进行处理而ForwardAuthenticationSuccessHandler类的内部是简单的请求转发当我们需要请求跳转到站外的地址或者在前后端分离的项目中登录请求跳转时，使用successForwardUrl()是不行的，这就需要我们去自定义控制器 自定义类自定义登录成功处理器，重写AuthenticationSuccessHandler接口中的方法 12345678910111213141516171819202122232425262728293031package com.example.demo.handler;import org.springframework.security.core.Authentication;import org.springframework.security.core.userdetails.User;import org.springframework.security.web.authentication.AuthenticationSuccessHandler;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;//自定义登陆成功处理器public class MyAuthenticationSuccessHandler implements AuthenticationSuccessHandler &#123; private String url; public MyAuthenticationSuccessHandler(String url) &#123; this.url = url; &#125; @Override public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException &#123; System.out.println(httpServletRequest.getRemoteAddr());//获取ip地址 User user = (User)authentication.getPrincipal();//Principl主体存放了登录用户的信息 System.out.println(user.getAuthorities());//权限 System.out.println(user.getPassword());//出于安全考虑，输出null,无法查看 System.out.println(user.getUsername()); httpServletResponse.sendRedirect(url);//重定向至设定的url &#125;&#125; Authentication源码 1234567891011121314//源码public interface Authentication extends Principal, Serializable &#123; Collection&lt;? extends GrantedAuthority&gt; getAuthorities();//获取权限 Object getCredentials();//获取凭证 Object getDetails();//获取详情 Object getPrincipal();//获取对象 boolean isAuthenticated(); void setAuthenticated(boolean var1) throws IllegalArgumentException;&#125; 同理 自定义登录失败处理器，重写AuthenticationFailureHandler接口中的方法 1234567891011121314151617181920212223package com.example.demo.handler;import org.springframework.security.core.AuthenticationException;import org.springframework.security.web.authentication.AuthenticationFailureHandler;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class MyAuthenticationFailureHandler implements AuthenticationFailureHandler &#123; private String url; public MyAuthenticationFailureHandler(String url) &#123; this.url = url; &#125; @Override public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException &#123; httpServletResponse.sendRedirect(url); &#125;&#125; 接下来需要去修改配置类,自定义控制器设定登录成功跳转到百度，登录失败跳转到知乎 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.example.demo.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;@Configuration//自定义登录页public class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http)throws Exception&#123; //登录 http.formLogin() //自定义登录页面 .loginPage(&quot;/login.html&quot;) //必须和表单提交的接口一致 .loginProcessingUrl(&quot;/login&quot;) //登录成功跳转的页面,POST请求 //.successForwardUrl(&quot;/toMain&quot;) //自定义登陆成功处理器 .successHandler(new MyAuthenticationSuccessHandler(&quot;https://www.baidu.com&quot;)) //.successHandler(new MyAuthenticationSuccessHandler(&quot;/main.html&quot;)) //登录失败后跳转的页面，post请求 //.failureForwardUrl(&quot;/toError&quot;) //自定义登陆失败处理器 .failureHandler(new MyAuthenticationFailureHandler(&quot;https://www.zhihu.com&quot;)); //.failureHandler(new MyAuthenticationFailureHandler(&quot;/error.html&quot;)); //授权 http.authorizeRequests() //放行login.html,无需验证 .antMatchers(&quot;/login.html&quot;).permitAll() //放行error.html,无需验证 .antMatchers(&quot;/error.html&quot;).permitAll() //所有请求都必须通过认证才能访问，(必须登录) .anyRequest().authenticated();//拦截所有请求，有先后顺序，anyRequest()放在最后 //关闭csrf防护 http.csrf().disable(); &#125; @Bean public PasswordEncoder getPw()&#123; return new BCryptPasswordEncoder(); &#125;&#125;","categories":[],"tags":[]},{"title":"SpringSecurity入门详解-易霭珞","slug":"hello-world","date":"2022-09-29T11:42:32.847Z","updated":"2022-11-30T13:16:42.686Z","comments":true,"path":"hello-world/","link":"","permalink":"https://yiailuo.github.io/hello-world/","excerpt":"","text":"1.安全框架概述什么是安全框架？解决系统安全问题的框架，如果没有安全框架，我们需要手动处理每个资源的访问控制，非常麻烦。使用安全框架，我们可以通过配置的方式实现对资源的访问控制 2.SpringSecurity：Spring家族的一员，是一个能够基于Spring的企业应用系统提供声明式的安全访问控制解决方案、高度自定义的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IOC（控制反转Inversion of Control ），DI（Dependency Injecion 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明示的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。它的核心功能是“认证”和“授权”。 2.入门demo1.导入依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;spingsecurity-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spingsecurity-demo&lt;/name&gt; &lt;description&gt;spingsecurity-demo&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;15&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; Spring Security已经被Spring boot进行集成，使用时直接引入启动器即可。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 2.访问页面导入spring-boot-starter-security启动器后，Spring Security已经生效，默认拦截全部请求，如果用户没有登录，跳转到内置登录页面。在浏览器中输入http://localhost:8080/login默认的username是user，默认的随机密码password会打印在控制台（每次项目启动后的密码都不同）3.可以自己自定义当前页面的用户名和密码通过修改application.properties(application.yml)配置文件 12spring.security.user.name=yiailuospring.security.user.password=yiailuo 4.UserDetailsService详解如果需要自定义登录逻辑需要实现UserDetailsService接口，它的返回值是UserDetails也是一个接口13~25行分别对应获取权限，获取密码，获取用户名，账号是否过期，账号是否被锁定，密码是否过期，是否可用 5.PasswordEncoder详解 encode() ：把参数按照特定的解析规则进行解析。matches() ：验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹配，则返回 true；如果不匹配，则返回 false。第一个参数表示需要被解析的密码。第二个参数表示存储的密码。upgradeEncoding() ：如果解析的密码能够再次进行解析且达到更安全的结果则返回true，否则返回 false。默认返回 false。 6.自定义登录逻辑 自定义逻辑 123456789101112131415161718192021222324252627282930package com.example.demo.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.core.authority.AuthorityUtils;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Service;@Servicepublic class UserDetailServiceImpl implements UserDetailsService &#123; //自定义登录逻辑 @Autowired private PasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; System.out.println(&quot;执行自定义登陆逻辑&quot;); //1.根据用户名去数据库查询，如果不存在抛出UserNameNotFound异常（正常情况下是去数据库查） //这里只是一个简单demo if(!&quot;yiailuo&quot;.equals(username))&#123; throw new UsernameNotFoundException(&quot;用户名不存在&quot;); &#125; //2.比较密码（注册时已经加密过的，如果匹配成功返回UserDetails） String password = passwordEncoder.encode(&quot;yiailuo&quot;); return new User(username,password, AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin,normal,ROLE_abc&quot;));//权限列表 &#125;&#125; 这里UserDetails实现User类的实例导包时注意！！！User类属于import org.springframework.security.core.userdetails.User;并不是自己创建的User类。有两个构造方法任选其一即可 自定义登录页面 登录页面login.html等静态资源放在resource&#x2F;static文件夹里login.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 登录成功的页面main.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登陆成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt;登陆成功！！！&lt;a href=&quot;main1.html&quot;&gt;跳转&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 登录失败的页面error.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;操作失败，请重新登录&lt;a href=&quot;/login.html&quot;&gt;跳转&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 编写配置类WebSecurityConfigurerAdapter在SpringSecurity5.7版本弃用了 1234567891011121314151617181920212223242526272829303132333435363738394041package com.example.demo.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;@Configuration//自定义登录页public class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http)throws Exception&#123; //登录 http.formLogin() //自定义登录页面 .loginPage(&quot;/login.html&quot;) //必须和表单提交的接口一致 .loginProcessingUrl(&quot;/login&quot;) //登录成功跳转的页面,POST请求 .successForwardUrl(&quot;/toMain&quot;) //登录失败后跳转的页面，post请求 .failureForwardUrl(&quot;/toError&quot;) //授权 http.authorizeRequests() //放行login.html,无需验证 .antMatchers(&quot;/login.html&quot;).permitAll() //放行error.html,无需验证 .antMatchers(&quot;/error.html&quot;).permitAll() //所有请求都必须通过认证才能访问，(必须登录) .anyRequest().authenticated();//拦截所有请求，有先后顺序，anyRequest()放在最后 //关闭csrf防护 http.csrf().disable(); &#125; @Bean public PasswordEncoder getPw()&#123; return new BCryptPasswordEncoder(); &#125;&#125; 编写控制器 12345678910111213141516package com.example.demo.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class LoginController &#123; @RequestMapping(&quot;/toMain&quot;) public String main()&#123; return &quot;redirect:main.html&quot;; &#125; @RequestMapping(&quot;/toError&quot;) public String error()&#123; return &quot;redirect:error.html&quot;; &#125;&#125; 启动项目后的登录页面输入设置好的用户名和密码，点击登录即可跳转到main.html,输入错误的用户名和密码即可跳转到error.html","categories":[],"tags":[]}],"categories":[],"tags":[]}